(function (Vue) {
  'use strict';

  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  /* Used to give each SVG a unique ID */
  var renderId = 0;

  /* Useful function for doing the calculations for animations without a massive Tween library */
  function animateCalc(
    oldVal,
    newVal,
    duration,
    callback,
    easingFunction
  ) {
    var curTime = new Date().getTime();
    var continueUpdating = true;
    var oldValDiff = newVal - oldVal;

    var doUpdate = function () {
      var timeDiff = new Date().getTime() - curTime;
      /* Math.min makes it so when we're over the time 
      limit we become equal to the new value and can stop updating. */
      var ratio = Math.min(timeDiff / duration, 1);
      var calcRatio = ratio;
      if (easingFunction) {
        calcRatio = easingFunction(ratio);
      }

      callback(oldVal + calcRatio * oldValDiff);

      if (ratio < 1 && continueUpdating) {
        window.requestAnimationFrame(function () { return doUpdate(); });
      }
    };
    window.requestAnimationFrame(function () { return doUpdate(); });

    return function() {
      continueUpdating = false;
    };
  }

  var script = {
    name: "k-guage",
    props: {
      title: {
        type: String
      },
      width: {
        type: Number,
        default: 200
      },
      height: {
        type: Number,
        default: 150
      },
      value: {
        default: 10
      },
      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },
      animationDuration: {
        type: Number,
        default: 1000
      },
      doughnut: {
        type: Boolean
      },
      formatFunction: {
        type: Function,
        default: Math.round
      },
      colorSteps: {
        type: Array,
        default: function () { return ["#a9d70b", "#f9c802", "#ff0000"]; }
      },
      valueFontStyle: {
        type: String,
        default:
          'font-size: 35px; fill: #010101; font-weight: bold; font-family: "Arial"'
      },
      labelFontStyle: {
        type: String,
        default: "font: 10px Arial; fill: #b3b3b3"
      },
      minMaxFontStyle: {
        type: String,
        default: "font: 10px Arial; fill: #b4b4b4"
      },
      animateOnLoad: {
        type: Boolean,
        default: true
      },
      labelText: {
        type: String,
        default: ""
      },
      showMinMax: {
        type: Boolean,
        default: true
      },
      guageSize: {
        type: Number,
        default: 1
      },
      shadowOpacity: {
        type: Number,
        default: 0.2
      },
      backgroundColor: {
        type: String,
        default: "#edebeb"
      },
      easingFunction: {
        type: Function,
        default: function (t) { return t * (2 - t); } /* Ease out quad */
      }
    },
    data: function data() {
      var intColors = this.colorSteps.map(function (color) {
        var asInt = [];
        for (var i = 1; i < color.length; i += 2) {
          asInt.push(parseInt(("0x" + (color.substr(i, 2)))));
        }
        return asInt;
      });

      return {
        shownValue: this.animateOnLoad ? this.min : this.value,
        printValue: this.animateOnLoad
          ? this.min
          : this.formatFunction(this.value),
        backgroundPath: "",
        guageColor: "",
        builtColorSteps: intColors,
        animationCanceler: null,
        renderId: ("k-guage-filter-" + (++renderId)),
        minTextX: 0,
        maxTextX: 0
      };
    },
    mounted: function mounted() {
      this.$watch(
        function (vm) { return [vm.height, vm.width, vm.doughnut, vm.guageSize]; },
        this.resetBgArc
      );
      this.resetBgArc();
    },
    methods: {
      makeArc: function makeArc(value) {
        /* Code used from JustGage http://justgage.com/ */

        var gws = this.guageSize;
        var dx = 0;
        var dy = 0;

        var w = 250;
        var h = this.doughnut ? 250 : 150;

        if (this.doughnut) {
          var alpha$1 =
            (1 - (2 * (value - this.min)) / (this.max - this.min)) * Math.PI;
          var Ro$1 = w * 0.5 - w / 20;
          var Ri$1 = Ro$1 - (w / 6.666666666666667) * gws;

          var Cx$1 = w * 0.5 + dx;
          var Cy$1 = h * 0.5 + dy;

          var maxTextX2$1 = Cx$1 + Ro$1 * Math.cos(alpha$1);
          var Yo$1 = Cy$1 - Ro$1 * Math.sin(alpha$1);
          var maxTextX1$1 = Cx$1 + Ri$1 * Math.cos(alpha$1);
          var Yi$1 = Cy$1 - Ri$1 * Math.sin(alpha$1);

          var path$1 = "M" + (Cx$1 - Ri$1) + "," + Cy$1 + " ";
          path$1 += "L" + (Cx$1 - Ro$1) + "," + Cy$1 + " ";
          if (value > (this.max - this.min) / 2) {
            path$1 += "A" + Ro$1 + "," + Ro$1 + " 0 0 1 " + (Cx$1 + Ro$1) + "," + Cy$1 + " ";
          }
          path$1 += "A" + Ro$1 + "," + Ro$1 + " 0 0 1 " + maxTextX2$1 + "," + Yo$1 + " ";
          path$1 += "L" + maxTextX1$1 + "," + Yi$1 + " ";
          if (value > (this.max - this.min) / 2) {
            path$1 += "A" + Ri$1 + "," + Ri$1 + " 0 0 0 " + (Cx$1 + Ri$1) + "," + Cy$1 + " ";
          }
          path$1 += "A" + Ri$1 + "," + Ri$1 + " 0 0 0 " + (Cx$1 - Ri$1) + "," + Cy$1 + " ";

          return {
            path: path$1,
            minTextX: 60,
            maxTextX: 190
          };
        }

        var alpha = (1 - (value - this.min) / (this.max - this.min)) * Math.PI;
        var Ro = w / 2 - w / 10;
        var Ri = Ro - (w / 6.666666666666667) * gws;

        var Cx = w / 2 + dx;
        var Cy = h / 1.5 + dy;

        var maxTextX2 = Cx + Ro * Math.cos(alpha);
        var Yo = Cy - Ro * Math.sin(alpha);
        var maxTextX1 = Cx + Ri * Math.cos(alpha);
        var Yi = Cy - Ri * Math.sin(alpha);

        var minTextX1 = Cx - Ro;
        var minTextX2 = Cx - Ri;
        var path = "M" + minTextX2 + "," + Cy + " ";
        path += "L" + minTextX1 + "," + Cy + " ";
        path += "A" + Ro + "," + Ro + " 0 0 1 " + maxTextX2 + "," + Yo + " ";
        path += "L" + maxTextX1 + "," + Yi + " ";
        path += "A" + Ri + "," + Ri + " 0 0 0 " + minTextX2 + "," + Cy + " ";
        path += "Z ";

        var minTextX = minTextX1 + (minTextX2 - minTextX1) * 0.5;
        var maxTextX = maxTextX1 + (maxTextX2 - maxTextX1) * 0.5;

        return { path: path, minTextX: minTextX, maxTextX: maxTextX };
      },
      resetBgArc: function resetBgArc() {
        var pathProps = this.makeArc(this.max);
        this.backgroundPath = pathProps.path;
        this.minTextX = pathProps.minTextX;
        this.maxTextX = pathProps.maxTextX;
      },
      getColorForValue: function getColorForValue(val) {
        var this$1 = this;

        var stepCount = this.builtColorSteps.length;
        if (val === this.max) {
          return this.builtColorSteps[stepCount - 1];
        }

        var ratio = val / this.max;
        var stepPosition = ratio * (stepCount - 1);
        var placement = Math.floor(stepPosition);
        var placementInStep = stepPosition % 1;

        var newColor = this.builtColorSteps[placement].map(function (color, i) {
          var compareTo = this$1.builtColorSteps[placement + 1][i];
          var diff = compareTo - color;
          return color + diff * placementInStep;
        });

        return newColor;
      },
      checkLimits: function checkLimits(val) {
        return Math.max(this.min, Math.min(this.max, val));
      }
    },
    computed: {
      guagePath: function guagePath() {
        return this.makeArc(this.shownValue);
      },
      strokeStyle: function strokeStyle() {
        if (!this.doughnut) {
          return "";
        } else {
          return "transform: rotate(90deg); transform-origin: 50% 50%";
        }
      }
    },
    watch: {
      value: {
        handler: function handler(newVal) {
          var this$1 = this;

          if (this.animationCanceler) {
            this.animationCanceler();
          }

          this.animationCanceler = animateCalc(
            this.shownValue,
            this.checkLimits(newVal),
            this.animationDuration,
            function (val) {
              this$1.shownValue = this$1.checkLimits(val);
              this$1.printValue = this$1.formatFunction(this$1.shownValue);
            },
            this.easingFunction
          );
        },
        immediate: true
      },
      shownValue: {
        handler: function handler(val) {
          var color = this.getColorForValue(val).join(",");
          this.guageColor = "rgb(" + color + ")";
        },
        immediate: true
      }
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
  /* server only */
  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    } // Vue.extend constructor export interop.


    var options = typeof script === 'function' ? script.options : script; // render functions

    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true; // functional template

      if (isFunctionalTemplate) {
        options.functional = true;
      }
    } // scopedId


    if (scopeId) {
      options._scopeId = scopeId;
    }

    var hook;

    if (moduleIdentifier) {
      // server build
      hook = function hook(context) {
        // 2.3 injection
        context = context || // cached call
        this.$vnode && this.$vnode.ssrContext || // stateful
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
        // 2.2 with runInNewContext: true

        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        } // inject component styles


        if (style) {
          style.call(this, createInjectorSSR(context));
        } // register component module identifier for async chunk inference


        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      }; // used by ssr in case component is cached and beforeCreate
      // never gets called


      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function () {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        style.call(this, createInjector(context));
      };
    }

    if (hook) {
      if (options.functional) {
        // register for functional component in vue file
        var originalRender = options.render;

        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }

    return script;
  }

  var normalizeComponent_1 = normalizeComponent;

  /* script */
  var __vue_script__ = script;

  /* template */
  var __vue_render__ = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "svg",
      {
        attrs: {
          height: _vm.height,
          version: "1.1",
          width: _vm.width,
          viewBox: "0 0 250 " + (_vm.doughnut ? 250 : 150),
          xmlns: "http://www.w3.org/2000/svg"
        }
      },
      [
        _vm.shadowOpacity
          ? _c(
              "filter",
              { attrs: { id: _vm.renderId } },
              [
                _c("feOffset", { attrs: { dx: "0", dy: "3" } }),
                _vm._v(" "),
                _c("feGaussianBlur", {
                  attrs: { result: "offset-blur", stdDeviation: "5" }
                }),
                _vm._v(" "),
                _c("feComposite", {
                  attrs: {
                    operator: "out",
                    in: "SourceGraphic",
                    in2: "offset-blur",
                    result: "inverse"
                  }
                }),
                _vm._v(" "),
                _c("feFlood", {
                  attrs: {
                    "flood-color": "black",
                    "flood-opacity": _vm.shadowOpacity,
                    result: "color"
                  }
                }),
                _vm._v(" "),
                _c("feComposite", {
                  attrs: {
                    operator: "in",
                    in: "color",
                    in2: "inverse",
                    result: "shadow"
                  }
                }),
                _vm._v(" "),
                _c("feComposite", {
                  attrs: { operator: "over", in: "shadow", in2: "SourceGraphic" }
                })
              ],
              1
            )
          : _vm._e(),
        _vm._v(" "),
        _vm.title
          ? _c(
              "text",
              {
                staticStyle: {
                  fill: "#999999",
                  "font-size": "16px",
                  "font-weight": "bold"
                },
                attrs: { y: "16", x: "125", "text-anchor": "middle" }
              },
              [_c("tspan", { domProps: { innerHTML: _vm._s(_vm.title) } })]
            )
          : _vm._e(),
        _vm._v(" "),
        _c(
          "g",
          {
            attrs: {
              transform: _vm.doughnut ? "translate(0 10)" : "translate(0 33)"
            }
          },
          [
            _c("path", {
              style: _vm.strokeStyle,
              attrs: {
                fill: _vm.backgroundColor,
                stroke: "none",
                d: _vm.backgroundPath,
                filter: "url(#" + _vm.renderId + ")"
              }
            }),
            _vm._v(" "),
            _c("path", {
              style: _vm.strokeStyle,
              attrs: {
                fill: _vm.guageColor,
                stroke: "none",
                d: _vm.guagePath.path,
                filter: "url(#" + _vm.renderId + ")"
              }
            }),
            _vm._v(" "),
            _c(
              "text",
              {
                style: _vm.valueFontStyle,
                attrs: {
                  x: "125",
                  y: _vm.doughnut ? 128 : 100,
                  "text-anchor": "middle"
                }
              },
              [_c("tspan", { domProps: { innerHTML: _vm._s(_vm.printValue) } })]
            ),
            _vm._v(" "),
            _c(
              "text",
              {
                style: _vm.labelFontStyle,
                attrs: {
                  x: "125",
                  y: _vm.doughnut ? 140 : 112,
                  "text-anchor": "middle"
                },
                domProps: { innerHTML: _vm._s(_vm.labelText) }
              },
              [_c("tspan", { domProps: { innerHTML: _vm._s(_vm.labelText) } })]
            ),
            _vm._v(" "),
            _vm.showMinMax
              ? _c(
                  "text",
                  {
                    style: _vm.minMaxFontStyle,
                    attrs: {
                      x: _vm.minTextX,
                      y: _vm.doughnut ? 133 : 116,
                      "text-anchor": "middle"
                    }
                  },
                  [_c("tspan", { domProps: { innerHTML: _vm._s(_vm.min) } })]
                )
              : _vm._e(),
            _vm._v(" "),
            _vm.showMinMax
              ? _c(
                  "text",
                  {
                    style: _vm.minMaxFontStyle,
                    attrs: {
                      x: _vm.maxTextX,
                      y: _vm.doughnut ? 133 : 116,
                      "text-anchor": "middle"
                    },
                    domProps: { innerHTML: _vm._s(_vm.max) }
                  },
                  [_c("tspan", { domProps: { innerHTML: _vm._s(_vm.max) } })]
                )
              : _vm._e()
          ]
        )
      ]
    )
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

    /* style */
    var __vue_inject_styles__ = undefined;
    /* scoped */
    var __vue_scope_id__ = undefined;
    /* module identifier */
    var __vue_module_identifier__ = undefined;
    /* functional template */
    var __vue_is_functional_template__ = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var KGuage = normalizeComponent_1(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      undefined,
      undefined
    );

  //

  var script$1 = {
    name: "app",
    components: {
      KGuage: KGuage
    },
    data: function data() {
      return {
        guage1: 60,
        guage2: 20,
        guage3: 40,
        guage4: 2000
      };
    },
    methods: {
      formatPct: function formatPct(v) {
        return ((Math.round(v)) + "%");
      },
      formatDollar: function formatDollar(v) {
        return ("$" + (v.toFixed(2)));
      },
      easeOutBounce: function easeOutBounce(pos) {
        if (pos < 1 / 2.75) {
          return 7.5625 * pos * pos;
        } else if (pos < 2 / 2.75) {
          return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
        } else if (pos < 2.5 / 2.75) {
          return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
        } else {
          return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
        }
      }
    },
    computed: {
      valInt: function valInt() {
        return parseInt(this.theVal);
      }
    }
  };

  var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
  function createInjector(context) {
    return function (id, style) {
      return addStyle(id, style);
    };
  }
  var HEAD = document.head || document.getElementsByTagName('head')[0];
  var styles = {};

  function addStyle(id, css) {
    var group = isOldIE ? css.media || 'default' : id;
    var style = styles[group] || (styles[group] = {
      ids: new Set(),
      styles: []
    });

    if (!style.ids.has(id)) {
      style.ids.add(id);
      var code = css.source;

      if (css.map) {
        // https://developer.chrome.com/devtools/docs/javascript-debugging
        // this makes source maps inside style tags work properly in Chrome
        code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

        code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
      }

      if (!style.element) {
        style.element = document.createElement('style');
        style.element.type = 'text/css';
        if (css.media) { style.element.setAttribute('media', css.media); }
        HEAD.appendChild(style.element);
      }

      if ('styleSheet' in style.element) {
        style.styles.push(code);
        style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
      } else {
        var index = style.ids.size - 1;
        var textNode = document.createTextNode(code);
        var nodes = style.element.childNodes;
        if (nodes[index]) { style.element.removeChild(nodes[index]); }
        if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }else { style.element.appendChild(textNode); }
      }
    }
  }

  var browser = createInjector;

  /* script */
  var __vue_script__$1 = script$1;

  /* template */
  var __vue_render__$1 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { attrs: { id: "app" } }, [
      _vm._m(0),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-guage", {
            attrs: {
              value: _vm.guage1,
              width: 500,
              height: 300,
              max: 300,
              "label-text": "GB",
              title: "Default Style"
            }
          }),
          _vm._v(" "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.guage1,
                expression: "guage1"
              }
            ],
            attrs: { type: "range", min: "0", max: "300" },
            domProps: { value: _vm.guage1 },
            on: {
              __r: function($event) {
                _vm.guage1 = $event.target.value;
              }
            }
          }),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v("Normal Setup (slider input is seperate component)")
          ])
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-guage", {
            attrs: {
              title: "Doughnut Style",
              value: _vm.guage2,
              width: 500,
              height: 300,
              max: 100,
              "label-text": "CPU",
              "guage-size": 1,
              "animate-duration": 3000,
              "shadow-opacity": 0.8,
              formatFunction: _vm.formatPct,
              "easing-function": _vm.easeOutBounce,
              "show-min-max": true,
              doughnut: true
            }
          }),
          _vm._v(" "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.guage2,
                expression: "guage2"
              }
            ],
            attrs: { type: "range", min: "0", max: "100" },
            domProps: { value: _vm.guage2 },
            on: {
              __r: function($event) {
                _vm.guage2 = $event.target.value;
              }
            }
          }),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v(
              "\n      Doughnut mode with a custom easing function, formatting function,\n      changed animation duration and custom shadow.\n    "
            )
          ])
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-guage", {
            attrs: {
              title: "Skinny Style",
              value: _vm.guage4,
              width: 500,
              height: 300,
              max: 5000,
              "label-text": "Visitors",
              "guage-size": 0.3,
              "animate-duration": 3000,
              "shadow-opacity": 0.3,
              "color-steps": ["#ff0004", "#ffff00", "#22ff29"],
              "show-min-max": false,
              doughnut: false
            }
          }),
          _vm._v(" "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.guage4,
                expression: "guage4"
              }
            ],
            attrs: { type: "range", min: "0", max: "5000" },
            domProps: { value: _vm.guage4 },
            on: {
              __r: function($event) {
                _vm.guage4 = $event.target.value;
              }
            }
          }),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v("Change size, shadow opacity, and hide mix and max.")
          ])
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-guage", {
            attrs: {
              title: "Styled Style",
              value: _vm.guage3,
              width: 500,
              height: 300,
              max: 200,
              "label-text": "Funds Raised",
              "guage-size": 0.5,
              "shadow-opacity": 0.8,
              formatFunction: _vm.formatDollar,
              "color-steps": [
                "#ff080c",
                "#ff54c9",
                "#8161ff",
                "#83ffb7",
                "#18ff27"
              ],
              "show-min-max": true,
              doughnut: false
            }
          }),
          _vm._v(" "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.guage3,
                expression: "guage3"
              }
            ],
            attrs: { type: "range", min: "0", max: "200" },
            domProps: { value: _vm.guage3 },
            on: {
              __r: function($event) {
                _vm.guage3 = $event.target.value;
              }
            }
          }),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v(
              "\n      Custom colors and formatting function. All font styles can be\n      overridden.\n    "
            )
          ])
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-guage"),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v(
              "\n      Super simple to use. Default config with just\n      <k-guage></k-guage>\n    "
            )
          ])
        ],
        1
      )
    ])
  };
  var __vue_staticRenderFns__$1 = [
    function() {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _c("div", { staticClass: "info" }, [
        _c("h3", [
          _vm._v("KGuage for Vue — Based off JustGage.js — Only 8kb unminified")
        ]),
        _vm._v(" "),
        _c("a", { attrs: { href: "https://github.com/agronick/KGauge" } }, [
          _vm._v("https://github.com/agronick/KGauge")
        ])
      ])
    }
  ];
  __vue_render__$1._withStripped = true;

    /* style */
    var __vue_inject_styles__$1 = function (inject) {
      if (!inject) { return }
      inject("data-v-92886732_0", { source: "\n#app {\n\ttext-align: center;\n}\n#app input {\n\tdisplay: block;\n\tmargin: 50px auto 0 auto;\n\twidth: 400px;\n}\n* {\n  font-family: sans-serif;\n}\nh3 {\n  color: #333;\n}\n#app .desc {\n\tfont-style: italic;\n\tcolor: #AAA;\n\tfont-size: 15px;\n\tmargin: 5px 0 123px;\n\tfont-family: sans-serif;\n}\nbody {\n\tbackground: #FFF;\n}\n.info {\n  margin-bottom: 50px;\n}\n", map: {"version":3,"sources":["/home/kyle/Apps/projects/KGauge/src/Examples.vue"],"names":[],"mappings":";AAqIA;CACA,kBAAA;AACA;AAEA;CACA,cAAA;CACA,wBAAA;CACA,YAAA;AACA;AAEA;EACA,uBAAA;AACA;AAEA;EACA,WAAA;AACA;AAEA;CACA,kBAAA;CACA,WAAA;CACA,eAAA;CACA,mBAAA;CACA,uBAAA;AACA;AAEA;CACA,gBAAA;AACA;AAEA;EACA,mBAAA;AACA","file":"Examples.vue","sourcesContent":["<template>\n  <div id=\"app\">\n    <div class=\"info\">\n      <h3>KGuage for Vue &mdash; Based off JustGage.js &mdash; Only 8kb unminified</h3>\n      <a href=\"https://github.com/agronick/KGauge\">https://github.com/agronick/KGauge</a>\n    </div>\n    <div>\n      <k-guage\n        :value=\"guage1\"\n        :width=\"500\"\n        :height=\"300\"\n        :max=\"300\"\n        label-text=\"GB\"\n        title=\"Default Style\"\n      />\n      <input type=\"range\" min=\"0\" max=\"300\" v-model=\"guage1\" />\n      <div class=\"desc\">Normal Setup (slider input is seperate component)</div>\n    </div>\n    <div>\n      <k-guage\n        title=\"Doughnut Style\"\n        :value=\"guage2\"\n        :width=\"500\"\n        :height=\"300\"\n        :max=\"100\"\n        label-text=\"CPU\"\n        :guage-size=\"1\"\n        :animate-duration=\"3000\"\n        :shadow-opacity=\"0.8\"\n        :formatFunction=\"formatPct\"\n        :easing-function=\"easeOutBounce\"\n        :show-min-max=\"true\"\n        :doughnut=\"true\"\n      />\n      <input type=\"range\" min=\"0\" max=\"100\" v-model=\"guage2\" />\n      <div class=\"desc\">\n        Doughnut mode with a custom easing function, formatting function,\n        changed animation duration and custom shadow.\n      </div>\n    </div>\n    <div>\n      <k-guage\n        title=\"Skinny Style\"\n        :value=\"guage4\"\n        :width=\"500\"\n        :height=\"300\"\n        :max=\"5000\"\n        label-text=\"Visitors\"\n        :guage-size=\"0.3\"\n        :animate-duration=\"3000\"\n        :shadow-opacity=\"0.3\"\n        :color-steps=\"['#ff0004', '#ffff00', '#22ff29']\"\n        :show-min-max=\"false\"\n        :doughnut=\"false\"\n      />\n      <input type=\"range\" min=\"0\" max=\"5000\" v-model=\"guage4\" />\n      <div class=\"desc\">Change size, shadow opacity, and hide mix and max.</div>\n    </div>\n    <div>\n      <k-guage\n        title=\"Styled Style\"\n        :value=\"guage3\"\n        :width=\"500\"\n        :height=\"300\"\n        :max=\"200\"\n        label-text=\"Funds Raised\"\n        :guage-size=\"0.5\"\n        :shadow-opacity=\"0.8\"\n        :formatFunction=\"formatDollar\"\n        :color-steps=\"['#ff080c', '#ff54c9', '#8161ff', '#83ffb7', '#18ff27']\"\n        :show-min-max=\"true\"\n        :doughnut=\"false\"\n      />\n      <input type=\"range\" min=\"0\" max=\"200\" v-model=\"guage3\" />\n      <div class=\"desc\">\n        Custom colors and formatting function. All font styles can be\n        overridden.\n      </div>\n    </div>\n    <div>\n      <k-guage></k-guage>\n      <div class=\"desc\">\n        Super simple to use. Default config with just\n        &lt;k-guage&gt;&lt;/k-guage&gt;\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport KGuage from \"./KGuage.vue\";\n\nexport default {\n  name: \"app\",\n  components: {\n    KGuage\n  },\n  data() {\n    return {\n      guage1: 60,\n      guage2: 20,\n      guage3: 40,\n      guage4: 2000\n    };\n  },\n  methods: {\n    formatPct(v) {\n      return `${Math.round(v)}%`;\n    },\n    formatDollar(v) {\n      return `$${v.toFixed(2)}`;\n    },\n    easeOutBounce(pos) {\n      if (pos < 1 / 2.75) {\n        return 7.5625 * pos * pos;\n      } else if (pos < 2 / 2.75) {\n        return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);\n      } else if (pos < 2.5 / 2.75) {\n        return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);\n      } else {\n        return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);\n      }\n    }\n  },\n  computed: {\n    valInt() {\n      return parseInt(this.theVal);\n    }\n  }\n};\n</script>\n\n<style>\n#app {\n\ttext-align: center;\n}\n\n#app input {\n\tdisplay: block;\n\tmargin: 50px auto 0 auto;\n\twidth: 400px;\n}\n\n* {\n  font-family: sans-serif;\n}\n\nh3 {\n  color: #333;\n}\n\n#app .desc {\n\tfont-style: italic;\n\tcolor: #AAA;\n\tfont-size: 15px;\n\tmargin: 5px 0 123px;\n\tfont-family: sans-serif;\n}\n\nbody {\n\tbackground: #FFF;\n}\n\n.info {\n  margin-bottom: 50px;\n}\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    var __vue_scope_id__$1 = undefined;
    /* module identifier */
    var __vue_module_identifier__$1 = undefined;
    /* functional template */
    var __vue_is_functional_template__$1 = false;
    /* style inject SSR */
    

    
    var Examples = normalizeComponent_1(
      { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
      __vue_inject_styles__$1,
      __vue_script__$1,
      __vue_scope_id__$1,
      __vue_is_functional_template__$1,
      __vue_module_identifier__$1,
      browser,
      undefined
    );

  Vue.config.productionTip = false;

  new Vue({
    render: function (h) { return h(Examples); }
  }).$mount("#app");

}(Vue));
