(function (Vue) {
  'use strict';

  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  /* Used to give each SVG a unique ID */
  var renderId = 0;

  /* Useful function for doing the calculations for animations without a massive Tween library */
  function animateCalc(
    oldVal,
    newVal,
    duration,
    callback,
    easingFunction
  ) {
    var curTime = new Date().getTime();
    var continueUpdating = true;
    var oldValDiff = newVal - oldVal;

    var doUpdate = function () {
      var timeDiff = new Date().getTime() - curTime;
      /* Math.min makes it so when we're over the time
      limit we become equal to the new value and can stop updating. */
      var ratio = Math.min(timeDiff / duration, 1);
      var calcRatio = ratio;
      if (easingFunction) {
        calcRatio = easingFunction(ratio);
      }

      callback(oldVal + calcRatio * oldValDiff);

      if (ratio < 1 && continueUpdating) {
        window.requestAnimationFrame(doUpdate);
      }
    };
    window.requestAnimationFrame(doUpdate);

    return function() {
      continueUpdating = false;
    };
  }

  var script = {
    name: "k-gauge",
    props: {
      title: {
        type: String
      },
      titleStyle: {
        type: String,
        default: "fill: #999999; font-size: 20px; font-weight: bold"
      },
      width: {
        type: [Number, String],
        default: 200
      },
      height: {
        type: [Number, String],
        default: 150
      },
      value: {
        default: 10
      },
      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },
      animationDuration: {
        type: Number,
        default: 1000
      },
      doughnut: {
        type: Boolean
      },
      formatFunction: {
        type: Function,
        default: Math.round
      },
      colorSteps: {
        type: Array,
        default: function () { return ["#a9d70b", "#f9c802", "#ff0000"]; }
      },
      valueFontStyle: {
        type: String,
        default:
          'font-size: 35px; fill: #010101; font-weight: bold; font-family: "Arial"'
      },
      labelFontStyle: {
        type: String,
        default: "font: 16px Arial; fill: #b3b3b3"
      },
      minMaxFontStyle: {
        type: String,
        default: "font: 16px Arial; fill: #b4b4b4"
      },
      animateOnLoad: {
        type: Boolean,
        default: true
      },
      labelText: {
        type: String,
        default: ""
      },
      showMinMax: {
        type: Boolean,
        default: true
      },
      gaugeSize: {
        type: Number,
        default: 1
      },
      shadowOpacity: {
        type: Number,
        default: 0.2
      },
      backgroundColor: {
        type: String,
        default: "#edebeb"
      },
      easingFunction: {
        type: Function,
        default: function (t) { return t * (2 - t); } /* Ease out quad */
      },
      maxTextFormatFn: {
        type: Function,
        default: function (f) { return f; }
      },
      minTextFormatFn: {
        type: Function,
        default: function (f) { return f; }
      },
    },
    data: function data() {
      var intColors = this.colorSteps.map(function (color) {
        var asInt = [];
        for (var i = 1; i < color.length; i += 2) {
          asInt.push(parseInt(("0x" + (color.substr(i, 2)))));
        }
        return asInt;
      });

      return {
        shownValue: this.animateOnLoad ? this.min : this.value,
        printValue: this.animateOnLoad
          ? this.min
          : this.formatFunction(this.value),
        backgroundPath: "",
        gaugeColor: "",
        builtColorSteps: intColors,
        animationCanceler: null,
        renderId: ("k-gauge-filter-" + (++renderId)),
        minTextX: 0,
        maxTextX: 0
      };
    },
    mounted: function mounted() {

      if (this.min === this.max) {
        throw Error("Min and max can not be equal")
      }

      this.$watch(
        function (vm) { return [vm.height, vm.width, vm.doughnut, vm.gaugeSize]; },
        this.resetBgArc
      );
      this.resetBgArc();
    },
    methods: {
      reverseValue: function reverseValue(value) {
        var range = this.max - this.min;
        var ratio = (value - this.min) / range;
        var pos = this.max - (range * ratio);
        return pos;
      },
      makeArc: function makeArc(value) {
        /* Code used from JustGage http://justgage.com/ */

        var gws = this.gaugeSize;
        var dx = 0;
        var dy = 0;

        var w = this.doughnut ? 220 : 250;
        var h = this.doughnut ? 250 : 150;

        if (this.doughnut) {
          var min, max;

          if (this.isReversed) {
            value = this.reverseValue(value);
            max = this.min - this.max;
            min = value - this.max;
          } else {
            max = this.max - this.min;
            min = value - this.min;
          }

          var alpha$1 = (1 - (2 * min) / max) * Math.PI;
          var Ro$1 = w * 0.5 - w / 20;
          var Ri$1 = Ro$1 - (w / 6.666666666666667) * gws;

          var Cx$1 = w * 0.5 + dx;
          var Cy$1 = h * 0.5 + dy;

          var maxTextX2$1 = Cx$1 + Ro$1 * Math.cos(alpha$1);
          var Yo$1 = Cy$1 - Ro$1 * Math.sin(alpha$1);
          var maxTextX1$1 = Cx$1 + Ri$1 * Math.cos(alpha$1);
          var Yi$1 = Cy$1 - Ri$1 * Math.sin(alpha$1);

          var path$1 = "M" + (Cx$1 - Ri$1) + "," + Cy$1 + " ";
          path$1 += "L" + (Cx$1 - Ro$1) + "," + Cy$1 + " ";
          if (min > max * 0.5) {
            path$1 += "A" + Ro$1 + "," + Ro$1 + " 0 0 1 " + (Cx$1 + Ro$1) + "," + Cy$1 + " ";
          }
          path$1 += "A" + Ro$1 + "," + Ro$1 + " 0 0 1 " + maxTextX2$1 + "," + Yo$1 + " ";
          path$1 += "L" + maxTextX1$1 + "," + Yi$1 + " ";
          if (min > max * 0.5) {
            path$1 += "A" + Ri$1 + "," + Ri$1 + " 0 0 0 " + (Cx$1 + Ri$1) + "," + Cy$1 + " ";
          }
          path$1 += "A" + Ri$1 + "," + Ri$1 + " 0 0 0 " + (Cx$1 - Ri$1) + "," + Cy$1 + " ";

          return {
            path: path$1,
            minTextX: 60,
            maxTextX: 190
          };
        }

        var alpha = (1 - (value - this.min) / (this.max - this.min)) * Math.PI;
        var Ro = w / 2 - w / 10;
        var Ri = Ro - (w / 6.666666666666667) * gws;

        var Cx = w / 2 + dx;
        var Cy = h / 1.5 + dy;

        var maxTextX2 = Cx + Ro * Math.cos(alpha);
        var Yo = Cy - Ro * Math.sin(alpha);
        var maxTextX1 = Cx + Ri * Math.cos(alpha);
        var Yi = Cy - Ri * Math.sin(alpha);

        var minTextX1 = Cx - Ro;
        var minTextX2 = Cx - Ri;
        var path = "M" + minTextX2 + "," + Cy + " ";
        path += "L" + minTextX1 + "," + Cy + " ";
        path += "A" + Ro + "," + Ro + " 0 0 1 " + maxTextX2 + "," + Yo + " ";
        path += "L" + maxTextX1 + "," + Yi + " ";
        path += "A" + Ri + "," + Ri + " 0 0 0 " + minTextX2 + "," + Cy + " ";
        path += "Z ";

        var minTextX = minTextX1 + (minTextX2 - minTextX1) * 0.5;
        var maxTextX = maxTextX1 + (maxTextX2 - maxTextX1) * 0.5;

        return { path: path, minTextX: minTextX, maxTextX: maxTextX };
      },
      resetBgArc: function resetBgArc() {
        var pathProps = this.makeArc(this.max);
        this.backgroundPath = pathProps.path;
        this.minTextX = pathProps.minTextX;
        this.maxTextX = pathProps.maxTextX;
      },
      getColorForValue: function getColorForValue(val) {
        var this$1 = this;


        var stepCount = this.builtColorSteps.length;
        if (val === this.max) {
          return this.builtColorSteps[stepCount - 1];
        }

        if (stepCount === 1) {
          return this.builtColorSteps[0];
        }

        var ratio = (val - this.min) / (this.max - this.min);
        var stepPosition = ratio * (stepCount - 1);
        var placement = Math.floor(stepPosition);
        var placementInStep = stepPosition % 1;

        var newColor = this.builtColorSteps[placement].map(function (color, i) {
          var compareTo = this$1.builtColorSteps[placement + 1][i];
          var diff = compareTo - color;
          return Math.round(color + diff * placementInStep);
        });

        return newColor;
      },
      checkLimits: function checkLimits(val) {
        return Math.max(
          this.isReversed ? this.max : this.min,
          Math.min(this.isReversed ? this.min : this.max, val)
        );
      }
    },
    computed: {
      gaugePath: function gaugePath() {
        return this.makeArc(this.shownValue);
      },
      strokeStyle: function strokeStyle() {
        if (!this.doughnut) {
          return "";
        } else {
          return "transform: rotate(90deg); transform-origin: 125px 125px";
        }
      },
      isReversed: function isReversed() {
        return this.min > this.max;
      },
      pathArgs: function pathArgs() {
        var args = {
          stroke: 'none',
          style: this.strokeStyle,
        };

        if (this.shadowOpacity) {
          args.filter = "url(#" + (this.renderId) + ")";
        }

        return args;
      }
    },
    watch: {
      value: {
        handler: function handler(newVal) {
          var this$1 = this;

          if (this.animationCanceler) {
            this.animationCanceler();
          }

          this.animationCanceler = animateCalc(
            this.shownValue,
            this.checkLimits(newVal),
            this.animationDuration,
            function (val) {
              this$1.shownValue = this$1.checkLimits(val);
              this$1.printValue = this$1.formatFunction(this$1.shownValue);
            },
            this.easingFunction
          );
        },
        immediate: true
      },
      shownValue: {
        handler: function handler(val) {
          var color = this.getColorForValue(val).join(",");
          this.gaugeColor = "rgb(" + color + ")";
        },
        immediate: true
      }
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
  /* server only */
  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    } // Vue.extend constructor export interop.


    var options = typeof script === 'function' ? script.options : script; // render functions

    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true; // functional template

      if (isFunctionalTemplate) {
        options.functional = true;
      }
    } // scopedId


    if (scopeId) {
      options._scopeId = scopeId;
    }

    var hook;

    if (moduleIdentifier) {
      // server build
      hook = function hook(context) {
        // 2.3 injection
        context = context || // cached call
        this.$vnode && this.$vnode.ssrContext || // stateful
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
        // 2.2 with runInNewContext: true

        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        } // inject component styles


        if (style) {
          style.call(this, createInjectorSSR(context));
        } // register component module identifier for async chunk inference


        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      }; // used by ssr in case component is cached and beforeCreate
      // never gets called


      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function () {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        style.call(this, createInjector(context));
      };
    }

    if (hook) {
      if (options.functional) {
        // register for functional component in vue file
        var originalRender = options.render;

        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }

    return script;
  }

  var normalizeComponent_1 = normalizeComponent;

  /* script */
  var __vue_script__ = script;

  /* template */
  var __vue_render__ = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "svg",
      {
        attrs: {
          height: _vm.height,
          version: "1.1",
          width: _vm.width,
          viewBox: "0 0 250 " + (_vm.doughnut ? 280 : 150),
          xmlns: "http://www.w3.org/2000/svg"
        }
      },
      [
        _vm.shadowOpacity
          ? _c(
              "filter",
              { attrs: { id: _vm.renderId } },
              [
                _c("feOffset", { attrs: { dx: "0", dy: "3" } }),
                _vm._v(" "),
                _c("feGaussianBlur", {
                  attrs: { result: "offset-blur", stdDeviation: "5" }
                }),
                _vm._v(" "),
                _c("feComposite", {
                  attrs: {
                    operator: "out",
                    in: "SourceGraphic",
                    in2: "offset-blur",
                    result: "inverse"
                  }
                }),
                _vm._v(" "),
                _c("feFlood", {
                  attrs: {
                    "flood-color": "black",
                    "flood-opacity": _vm.shadowOpacity,
                    result: "color"
                  }
                }),
                _vm._v(" "),
                _c("feComposite", {
                  attrs: {
                    operator: "in",
                    in: "color",
                    in2: "inverse",
                    result: "shadow"
                  }
                }),
                _vm._v(" "),
                _c("feComposite", {
                  attrs: { operator: "over", in: "shadow", in2: "SourceGraphic" }
                })
              ],
              1
            )
          : _vm._e(),
        _vm._v(" "),
        _vm.title
          ? _c(
              "text",
              {
                style: _vm.titleStyle,
                attrs: { y: "15", x: "125", "text-anchor": "middle" }
              },
              [_c("tspan", { domProps: { innerHTML: _vm._s(_vm.title) } })]
            )
          : _vm._e(),
        _vm._v(" "),
        _c("g", { attrs: { transform: "translate(0 20)" } }, [
          _c(
            "path",
            _vm._b(
              { attrs: { fill: _vm.backgroundColor, d: _vm.backgroundPath } },
              "path",
              _vm.pathArgs,
              false
            )
          ),
          _vm._v(" "),
          _c(
            "path",
            _vm._b(
              { attrs: { fill: _vm.gaugeColor, d: _vm.gaugePath.path } },
              "path",
              _vm.pathArgs,
              false
            )
          ),
          _vm._v(" "),
          _c(
            "text",
            {
              style: _vm.valueFontStyle,
              attrs: {
                x: "125",
                y: _vm.doughnut ? 118 : 100,
                "text-anchor": "middle"
              }
            },
            [_c("tspan", { domProps: { innerHTML: _vm._s(_vm.printValue) } })]
          ),
          _vm._v(" "),
          _c(
            "text",
            {
              style: _vm.labelFontStyle,
              attrs: {
                x: "125",
                y: _vm.doughnut ? 142 : 120,
                "text-anchor": "middle"
              },
              domProps: { innerHTML: _vm._s(_vm.labelText) }
            },
            [_c("tspan", { domProps: { innerHTML: _vm._s(_vm.labelText) } })]
          ),
          _vm._v(" "),
          _vm.showMinMax && !_vm.doughnut
            ? _c(
                "text",
                {
                  style: _vm.minMaxFontStyle,
                  attrs: { x: _vm.minTextX, y: 120, "text-anchor": "middle" }
                },
                [
                  _c("tspan", {
                    domProps: { innerHTML: _vm._s(_vm.minTextFormatFn(_vm.min)) }
                  })
                ]
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.showMinMax && !_vm.doughnut
            ? _c(
                "text",
                {
                  style: _vm.minMaxFontStyle,
                  attrs: { x: _vm.maxTextX, y: 120, "text-anchor": "middle" }
                },
                [
                  _c("tspan", {
                    domProps: { innerHTML: _vm._s(_vm.maxTextFormatFn(_vm.max)) }
                  })
                ]
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.showMinMax && _vm.doughnut
            ? _c(
                "text",
                {
                  style: _vm.minMaxFontStyle,
                  attrs: { x: 125, y: 240, "text-anchor": "middle" }
                },
                [
                  _c("tspan", [
                    _vm._v(_vm._s(_vm.max) + " " + _vm._s(_vm.labelText))
                  ])
                ]
              )
            : _vm._e()
        ])
      ]
    )
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

    /* style */
    var __vue_inject_styles__ = undefined;
    /* scoped */
    var __vue_scope_id__ = undefined;
    /* module identifier */
    var __vue_module_identifier__ = undefined;
    /* functional template */
    var __vue_is_functional_template__ = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var KGauge = normalizeComponent_1(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      undefined,
      undefined
    );

  //

  var script$1 = {
    name: "app",
    components: {
      KGauge: KGauge
    },
    data: function data() {
      return {
        gauge1: 60,
        gauge2: 73,
        gauge3: 40,
        gauge4: 3700,
        gauge5: 50
      };
    },
    methods: {
      formatPct: function formatPct(v) {
        return ((Math.round(v)) + "%");
      },
      formatDollar: function formatDollar(v) {
        return ("$" + (v.toFixed(2)));
      },
      easeOutBounce: function easeOutBounce(pos) {
        if (pos < 1 / 2.75) {
          return 7.5625 * pos * pos;
        } else if (pos < 2 / 2.75) {
          return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
        } else if (pos < 2.5 / 2.75) {
          return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
        } else {
          return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
        }
      }
    },
    computed: {
      valInt: function valInt() {
        return parseInt(this.theVal);
      }
    }
  };

  var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
  function createInjector(context) {
    return function (id, style) {
      return addStyle(id, style);
    };
  }
  var HEAD = document.head || document.getElementsByTagName('head')[0];
  var styles = {};

  function addStyle(id, css) {
    var group = isOldIE ? css.media || 'default' : id;
    var style = styles[group] || (styles[group] = {
      ids: new Set(),
      styles: []
    });

    if (!style.ids.has(id)) {
      style.ids.add(id);
      var code = css.source;

      if (css.map) {
        // https://developer.chrome.com/devtools/docs/javascript-debugging
        // this makes source maps inside style tags work properly in Chrome
        code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

        code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
      }

      if (!style.element) {
        style.element = document.createElement('style');
        style.element.type = 'text/css';
        if (css.media) { style.element.setAttribute('media', css.media); }
        HEAD.appendChild(style.element);
      }

      if ('styleSheet' in style.element) {
        style.styles.push(code);
        style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
      } else {
        var index = style.ids.size - 1;
        var textNode = document.createTextNode(code);
        var nodes = style.element.childNodes;
        if (nodes[index]) { style.element.removeChild(nodes[index]); }
        if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }else { style.element.appendChild(textNode); }
      }
    }
  }

  var browser = createInjector;

  /* script */
  var __vue_script__$1 = script$1;

  /* template */
  var __vue_render__$1 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { attrs: { id: "app" } }, [
      _vm._m(0),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-gauge", {
            attrs: {
              value: _vm.gauge1,
              width: 500,
              height: 300,
              max: 300,
              "label-text": "GB",
              title: "Default Gauge"
            }
          }),
          _vm._v(" "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.gauge1,
                expression: "gauge1"
              }
            ],
            attrs: { type: "range", min: "0", max: "300" },
            domProps: { value: _vm.gauge1 },
            on: {
              __r: function($event) {
                _vm.gauge1 = $event.target.value;
              }
            }
          }),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v("Normal Setup (slider input is seperate component)")
          ])
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-gauge", {
            attrs: {
              title: "Doughnut Gauge",
              value: _vm.gauge2,
              width: 500,
              height: 300,
              max: 100,
              "label-text": "CPU",
              "gauge-size": 1,
              "animate-duration": 3000,
              "shadow-opacity": 0.8,
              formatFunction: _vm.formatPct,
              "easing-function": _vm.easeOutBounce,
              "show-min-max": false,
              doughnut: true
            }
          }),
          _vm._v(" "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.gauge2,
                expression: "gauge2"
              }
            ],
            attrs: { type: "range", min: "0", max: "100" },
            domProps: { value: _vm.gauge2 },
            on: {
              __r: function($event) {
                _vm.gauge2 = $event.target.value;
              }
            }
          }),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v(
              "\n      Doughnut mode with a custom easing function, formatting function,\n      changed animation duration and custom shadow.\n    "
            )
          ])
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-gauge", {
            attrs: {
              title: "Skinny Gauge",
              value: _vm.gauge4,
              width: 500,
              height: 300,
              max: 5000,
              "label-text": "Visitors",
              "gauge-size": 0.3,
              "animate-duration": 3000,
              "shadow-opacity": 0.3,
              "color-steps": ["#ff0004", "#ffff00", "#22ff29"],
              "show-min-max": false,
              doughnut: false,
              "title-style":
                "fill: #999999; font-size: 12px; font-weight: 600; transform: translateY(-5px)"
            }
          }),
          _vm._v(" "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.gauge4,
                expression: "gauge4"
              }
            ],
            attrs: { type: "range", min: "0", max: "5000" },
            domProps: { value: _vm.gauge4 },
            on: {
              __r: function($event) {
                _vm.gauge4 = $event.target.value;
              }
            }
          }),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v("Change size, shadow opacity, and hide mix and max.")
          ])
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-gauge", {
            attrs: {
              title: "Gauge with Custom Styles",
              value: _vm.gauge3,
              width: 500,
              height: 300,
              max: 200,
              "label-text": "Funds Raised",
              "gauge-size": 0.5,
              "shadow-opacity": 0.8,
              "format-function": _vm.formatDollar,
              "min-text-format-fn": _vm.formatDollar,
              "max-text-format-fn": _vm.formatDollar,
              "title-style":
                "fill: #999999; font-size: 12px; font-weight: 600;  transform: translateY(-5px)",
              "min-max-font-style":
                "font: 9px Arial; fill: #b4b4b4; transform: translateY(-10px)",
              "color-steps": [
                "#ff080c",
                "#ff54c9",
                "#8161ff",
                "#83ffb7",
                "#18ff27"
              ],
              "show-min-max": true,
              doughnut: false
            }
          }),
          _vm._v(" "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.gauge3,
                expression: "gauge3"
              }
            ],
            attrs: { type: "range", min: "0", max: "200" },
            domProps: { value: _vm.gauge3 },
            on: {
              __r: function($event) {
                _vm.gauge3 = $event.target.value;
              }
            }
          }),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v(
              "\n      Custom colors and formatting function on value and min and max. \n      All font styles can be overridden.\n    "
            )
          ])
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-gauge", {
            attrs: {
              title: "Basic Doughnut",
              value: _vm.gauge5,
              "color-steps": ["#ffa726"],
              width: 500,
              height: 300,
              max: 100,
              "gauge-size": 0.4,
              formatFunction: function(x) {
                return x.toFixed(2) + "%"
              },
              "show-min-max": false,
              doughnut: true,
              "shadow-opacity": 0
            }
          }),
          _vm._v(" "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.gauge5,
                expression: "gauge5"
              }
            ],
            attrs: { type: "range", min: "0", max: "100" },
            domProps: { value: _vm.gauge5 },
            on: {
              __r: function($event) {
                _vm.gauge5 = $event.target.value;
              }
            }
          }),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v("Single color with shadows disabled.")
          ])
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        [
          _c("k-gauge"),
          _vm._v(" "),
          _c("div", { staticClass: "desc" }, [
            _vm._v(
              "\n      Super simple to use. Default config with just\n      <k-gauge></k-gauge>\n    "
            )
          ])
        ],
        1
      )
    ])
  };
  var __vue_staticRenderFns__$1 = [
    function() {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _c("div", { staticClass: "info" }, [
        _c("h3", [
          _vm._v(
            "\n      KGauge for Vue — Based off JustGage.js — Only 8kb minified uncompressed \n    "
          )
        ]),
        _vm._v(" "),
        _c("a", { attrs: { href: "https://github.com/agronick/KGauge" } }, [
          _vm._v("https://github.com/agronick/KGauge")
        ])
      ])
    }
  ];
  __vue_render__$1._withStripped = true;

    /* style */
    var __vue_inject_styles__$1 = function (inject) {
      if (!inject) { return }
      inject("data-v-70c22f8e_0", { source: "\n#app {\n  text-align: center;\n}\n#app input {\n  display: block;\n  margin: 50px auto 0 auto;\n  width: 400px;\n}\n* {\n  font-family: sans-serif;\n}\nh3 {\n  color: #333;\n}\n#app .desc {\n  font-style: italic;\n  color: #aaa;\n  font-size: 15px;\n  margin: 5px 0 123px;\n  font-family: sans-serif;\n}\nbody {\n  background: #fff;\n}\n.info {\n  margin-bottom: 50px;\n}\n", map: {"version":3,"sources":["/home/kyle/Apps/projects/KGauge/src/Examples.vue"],"names":[],"mappings":";AAgKA;EACA,kBAAA;AACA;AAEA;EACA,cAAA;EACA,wBAAA;EACA,YAAA;AACA;AAEA;EACA,uBAAA;AACA;AAEA;EACA,WAAA;AACA;AAEA;EACA,kBAAA;EACA,WAAA;EACA,eAAA;EACA,mBAAA;EACA,uBAAA;AACA;AAEA;EACA,gBAAA;AACA;AAEA;EACA,mBAAA;AACA","file":"Examples.vue","sourcesContent":["<template>\n  <div id=\"app\">\n    <div class=\"info\">\n      <h3>\n        KGauge for Vue &mdash; Based off JustGage.js &mdash; Only 8kb minified uncompressed \n      </h3>\n      <a href=\"https://github.com/agronick/KGauge\"\n        >https://github.com/agronick/KGauge</a\n      >\n    </div>\n    <div>\n      <k-gauge\n        :value=\"gauge1\"\n        :width=\"500\"\n        :height=\"300\"\n        :max=\"300\"\n        label-text=\"GB\"\n        title=\"Default Gauge\"\n      />\n      <input type=\"range\" min=\"0\" max=\"300\" v-model=\"gauge1\" />\n      <div class=\"desc\">Normal Setup (slider input is seperate component)</div>\n    </div>\n    <div>\n      <k-gauge\n        title=\"Doughnut Gauge\"\n        :value=\"gauge2\"\n        :width=\"500\"\n        :height=\"300\"\n        :max=\"100\"\n        label-text=\"CPU\"\n        :gauge-size=\"1\"\n        :animate-duration=\"3000\"\n        :shadow-opacity=\"0.8\"\n        :formatFunction=\"formatPct\"\n        :easing-function=\"easeOutBounce\"\n        :show-min-max=\"false\"\n        :doughnut=\"true\"\n      />\n      <input type=\"range\" min=\"0\" max=\"100\" v-model=\"gauge2\" />\n      <div class=\"desc\">\n        Doughnut mode with a custom easing function, formatting function,\n        changed animation duration and custom shadow.\n      </div>\n    </div>\n    <div>\n      <k-gauge\n        title=\"Skinny Gauge\"\n        :value=\"gauge4\"\n        :width=\"500\"\n        :height=\"300\"\n        :max=\"5000\"\n        label-text=\"Visitors\"\n        :gauge-size=\"0.3\"\n        :animate-duration=\"3000\"\n        :shadow-opacity=\"0.3\"\n        :color-steps=\"['#ff0004', '#ffff00', '#22ff29']\"\n        :show-min-max=\"false\"\n        :doughnut=\"false\"\n        title-style=\"fill: #999999; font-size: 12px; font-weight: 600; transform: translateY(-5px)\"\n      />\n      <input type=\"range\" min=\"0\" max=\"5000\" v-model=\"gauge4\" />\n      <div class=\"desc\">Change size, shadow opacity, and hide mix and max.</div>\n    </div>\n    <div>\n      <k-gauge\n        title=\"Gauge with Custom Styles\"\n        :value=\"gauge3\"\n        :width=\"500\"\n        :height=\"300\"\n        :max=\"200\"\n        label-text=\"Funds Raised\"\n        :gauge-size=\"0.5\"\n        :shadow-opacity=\"0.8\"\n        :format-function=\"formatDollar\"\n        :min-text-format-fn=\"formatDollar\"\n        :max-text-format-fn=\"formatDollar\"\n        title-style=\"fill: #999999; font-size: 12px; font-weight: 600;  transform: translateY(-5px)\"\n        min-max-font-style=\"font: 9px Arial; fill: #b4b4b4; transform: translateY(-10px)\"\n        :color-steps=\"['#ff080c', '#ff54c9', '#8161ff', '#83ffb7', '#18ff27']\"\n        :show-min-max=\"true\"\n        :doughnut=\"false\"\n      />\n      <input type=\"range\" min=\"0\" max=\"200\" v-model=\"gauge3\" />\n      <div class=\"desc\">\n        Custom colors and formatting function on value and min and max. \n        All font styles can be overridden.\n      </div>\n    </div>\n    <div>\n      <k-gauge\n        title=\"Basic Doughnut\"\n        :value=\"gauge5\"\n        :color-steps=\"['#ffa726']\"\n        :width=\"500\"\n        :height=\"300\"\n        :max=\"100\"\n        :gauge-size=\"0.4\"\n        :formatFunction=\"(x) => `${x.toFixed(2)}%`\"\n        :show-min-max=\"false\"\n        :doughnut=\"true\"\n        :shadow-opacity=\"0\"\n      />\n      <input type=\"range\" min=\"0\" max=\"100\" v-model=\"gauge5\" />\n      <div class=\"desc\">Single color with shadows disabled.</div>\n    </div>\n    <div>\n      <k-gauge></k-gauge>\n      <div class=\"desc\">\n        Super simple to use. Default config with just\n        &lt;k-gauge&gt;&lt;/k-gauge&gt;\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport KGauge from \"./KGauge.vue\";\n\nexport default {\n  name: \"app\",\n  components: {\n    KGauge\n  },\n  data() {\n    return {\n      gauge1: 60,\n      gauge2: 73,\n      gauge3: 40,\n      gauge4: 3700,\n      gauge5: 50\n    };\n  },\n  methods: {\n    formatPct(v) {\n      return `${Math.round(v)}%`;\n    },\n    formatDollar(v) {\n      return `$${v.toFixed(2)}`;\n    },\n    easeOutBounce(pos) {\n      if (pos < 1 / 2.75) {\n        return 7.5625 * pos * pos;\n      } else if (pos < 2 / 2.75) {\n        return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);\n      } else if (pos < 2.5 / 2.75) {\n        return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);\n      } else {\n        return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);\n      }\n    }\n  },\n  computed: {\n    valInt() {\n      return parseInt(this.theVal);\n    }\n  }\n};\n</script>\n\n<style>\n#app {\n  text-align: center;\n}\n\n#app input {\n  display: block;\n  margin: 50px auto 0 auto;\n  width: 400px;\n}\n\n* {\n  font-family: sans-serif;\n}\n\nh3 {\n  color: #333;\n}\n\n#app .desc {\n  font-style: italic;\n  color: #aaa;\n  font-size: 15px;\n  margin: 5px 0 123px;\n  font-family: sans-serif;\n}\n\nbody {\n  background: #fff;\n}\n\n.info {\n  margin-bottom: 50px;\n}\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    var __vue_scope_id__$1 = undefined;
    /* module identifier */
    var __vue_module_identifier__$1 = undefined;
    /* functional template */
    var __vue_is_functional_template__$1 = false;
    /* style inject SSR */
    

    
    var Examples = normalizeComponent_1(
      { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
      __vue_inject_styles__$1,
      __vue_script__$1,
      __vue_scope_id__$1,
      __vue_is_functional_template__$1,
      __vue_module_identifier__$1,
      browser,
      undefined
    );

  Vue.config.productionTip = false;

  new Vue({
    render: function (h) { return h(Examples); }
  }).$mount("#app");

}(Vue));
